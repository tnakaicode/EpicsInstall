<html><head><title>EPICS::IOC</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="../style.css">

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.35,
  using Pod::Simple::PullParser v3.35,
  under Perl v5.026001 at Sat Dec 15 09:14:01 2018 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u'
name="NAME"
>NAME</a></h1>

<p>EPICS::IOC - Manage an EPICS IOC</p>

<h1><a class='u'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use EPICS::IOC;

    my $ioc = EPICS::IOC-&#62;new;
    $ioc-&#62;debug(1);       # Show IOC stdio streams

    $ioc-&#62;start(&#39;bin/@ARCH@/ioc&#39;, &#39;iocBoot/ioc/st.cmd&#39;);
    $ioc-&#62;cmd;            # Wait for the iocsh prompt

    my @records = $ioc-&#62;dbl;
    my @values = map { $ioc-&#62;dbgf($_); } @records;

    $ioc-&#62;kill;</pre>

<h1><a class='u'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides an object-oriented API for starting, interacting with and stopping one or more EPICS IOCs under program control, and is generally intended for writing test programs.</p>

<p>The IOC should not be configured to emit unsolicited messages on stdout as this could interfere with the ability of the software to detect an end-of-command from the IOC shell, which is achieved by setting the prompt to a known string (normally <code>__END__</code>). Unsolicited messages on stderr will not cause problems, but can&#39;t be seen on Windows systems.</p>

<h1><a class='u'
name="CONSTRUCTOR"
>CONSTRUCTOR</a></h1>

<dl>
<dt><a name="new_()"
>new ()</a></dt>

<dd>
<p>Calling <code>new</code> creates an <code>EPICS::IOC</code> object that can be used to start and interact with a single IOC. After this IOC has been shut down (by calling its <code>kill</code> method) the <code>EPICS::IOC</code> object may be reused for another IOC.</p>
</dd>
</dl>

<h1><a class='u'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="debug_(_[FLAG]_)"
>debug ( [FLAG] )</a></dt>

<dd>
<p>Each <code>EPICS::IOC</code> object has its own debug flag which when non-zero causes all IOC console traffic sent or read by other methods to be printed to stdout along with the IOC&#39;s pid and a direction indicator. The <code>debug</code> method optionally sets and returns the value of this flag.</p>

<p>The optional FLAG is treated as a true/false value. If provided this sets the debug flag value.</p>

<p>The method&#39;s return value is the current (new if given) value of the flag.</p>

<dt><a name="start_(_EXECUTABLE_[,_ARGUMENTS_...]_)"
>start ( EXECUTABLE [, ARGUMENTS ...] )</a></dt>

<dd>
<p>Launch an IOC binary given by EXECUTABLE with ARGUMENTS. The method dies if it can&#39;t run the program as given, or if the IOC is already running.</p>

<p>In most cases the <code>cmd</code> method should be called next with no command string, which waits for the IOC&#39;s boot process to finish and the first iocsh prompt to be displayed.</p>

<p>The <code>start</code> method sets two environment variables that control how the IOC shell behaves: <code>IOCSH_HISTEDIT_DISABLE</code> is set to prevent it calling the GNU Readline library, and <code>IOCSH_PS1</code> is set to a known string which is used as a terminator for the previous command.</p>

<dt><a name="pid_()"
>pid ()</a></dt>

<dd>
<p>Returns the process-ID of the IOC process, or undef if the IOC process has not yet been started.</p>

<dt><a name="started_()"
>started ()</a></dt>

<dd>
<p>Returns a true value if the IOC has been started and not yet killed. This state will not change if the IOC dies by itself, it indicates that the start method has been called without the kill method.</p>

<dt><a name="_send_(_COMMAND_)"
>_send ( COMMAND )</a></dt>

<dd>
<p>The <code>_send</code> method is a primitive for internal use that sends a COMMAND string to the IOC shell, and prints it to stdout if the debug flag is set.</p>

<dt><a name="_getline_()"
>_getline ()</a></dt>

<dd>
<p>The <code>_getline</code> method is also designed for internal use, it fetches a single line output by the IOC, and prints it to stdout if the debug flag is set.</p>

<p>Any CR/LF is stripped from the line before returning it. If the stream gets closed because the IOC shuts down an <code>EOF</code> debug message may be shown and an undef value will be returned.</p>

<dt><a name="_getlines_(_[TERM]_)"
>_getlines ( [TERM] )</a></dt>

<dd>
<p>Another internal method <code>_getlines</code> fetches multiple lines from the IOC. It takes an optional TERM string or regexp parameter which is matched against each input line in turn to determine when the IOC&#39;s output has been completed. Termination also occurs on an EOF from the output stream.</p>

<p>The return value is a list of all the lines received (with the final CR/LF stripped) including the line that matched the terminator.</p>

<dt><a name="_geterrors_(_)"
>_geterrors ( )</a></dt>

<dd>
<p>Returns a list of lines output by the IOC to stderr since last called. Only complete lines are included, and trailing newlines have been removed.</p>

<p>NOTE: This doesn&#39;t work on Windows because it uses select which Perl doesn&#39;t support on that OS, but it doesn&#39;t seem to cause any problems for short-lived IOCs at least, it just never returns any text from the IOC&#39;s stderr output.</p>

<dt><a name="cmd_(_[COMMAND_[,_ARGUMENTS_...]]_)"
>cmd ( [COMMAND [, ARGUMENTS ...]] )</a></dt>

<dd>
<p>If the <code>cmd</code> method is given an optional COMMAND string along with any number of ARGUMENTS it constructs a command-line, quoting each argument as necessary. This is sent to the IOC and a line read back and discarded if it matches the command-line.</p>

<p>With no COMMAND string the method starts here; it then collects lines from the IOC until one matches the terminator. A list of all the lines received prior to the terminator line is returned.</p>

<dt><a name="kill_()"
>kill ()</a></dt>

<dd>
<p>The <code>kill</code> method attempts to stop an IOC that is still running in several ways. First it sends an <code>exit</code> command to the IOC shell. Next it closes the IOC&#39;s stdin stream which will trigger an end-of-file on that stream, and it fetches any remaining lines from the IOC&#39;s stdout stream before closing both that and the stderr stream. Finally (unless running on MS-Windows) it sends a SIGTERM signal to the child process and waits for it to clean up.</p>

<dt><a name="DESTROY_()"
>DESTROY ()</a></dt>

<dd>
<p><code>EPICS::IOC</code> objects have a destructor which calls the <code>kill</code> method, but it is not recommended that this be relied on to terminate an IOC process. Better to use an <code>END {}</code> block and/or trap the necessary signals to explicitly kill the IOC.</p>
</dd>
</dl>

<h1><a class='u'
name="CONVENIENCE_METHODS"
>CONVENIENCE METHODS</a></h1>

<p>The following methods provide an easy way to perform various common IOC operations.</p>

<dl>
<dt><a name="dbLoadRecords_(_FILE_[,_MACROS]_)"
>dbLoadRecords ( FILE [, MACROS] )</a></dt>

<dd>
<p>Instructs the IOC to load a database (.db) from FILE. If provided, the MACROS parameter is a single string containing one or more comma-separated assignment statements like <code>a=1</code> for macros that are used in the database file.</p>

<p>This method can also be used to load a database definition (.dbd) file.</p>

<dt><a name="iocInit_()"
>iocInit ()</a></dt>

<dd>
<p>Start the IOC executing.</p>

<dt><a name="dbl_(_[RECORDTYPE])"
>dbl ( [RECORDTYPE])</a></dt>

<dd>
<p>This method uses the <code>dbl</code> command to fetch a list of all of the record names the IOC has loaded. If a RECORDTYPE name is given, the list will only comprise records of that type.</p>

<dt><a name="dbgf_(_PV_)"
>dbgf ( PV )</a></dt>

<dd>
<p>The <code>dbgf</code> method returns the value of the process variable PV, or <code>undef</code> if the PV doesn&#39;t exist. This only works when the PV holds a scalar or an array with one element.</p>

<dt><a name="dbpf_(_PV,_VALUE_)"
>dbpf ( PV, VALUE )</a></dt>

<dd>
<p>This method sets PV to VALUE, and returns the new value, or <code>undef</code> if the PV doesn&#39;t exist. If the put fails the return value is the previous value of the PV. As with the <code>dbgf</code> method this only works for scalar or single-element arrays, but PV may be an array field which will be set to one element.</p>
</dd>
</dl>

<h1><a class='u'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Portions Copyright (C) 2011 UChicago Argonne LLC, as Operator of Argonne National Laboratory.</p>

<p>This software is distributed under the terms of the EPICS Open License.</p>

<!-- end doc -->

</body></html>
